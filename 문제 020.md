## 수 정렬하기 2

문제

N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.

입력

첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 

둘째 줄부터 N개의 줄에는 수가 주어진다. 

이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 

수는 중복되지 않는다.

출력

첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

### 문제 분석하기

시간제한이 2초이므로 2억번의 연산안에 해결해야 한다.

여기서 N개의 수인데 N의 범위가 100만이므로

N^2의 정렬을 수행하는 버블정렬, 선택정렬, 삽입정렬은 사용 할 수 없다.

따라서 O(nlogn)의 시간복잡도를 가지는 퀵정렬과 병합정렬이 있는데

여기서는 병합정렬로 문제를 해결한다.

### 손으로 풀어보기

주어진 숫자가 5 4 3 2 1 이다.

처음에 각각의 원소집합의 크기가 1이될때까지 분할하면

[5,4,3], [2,1] -> [5,4],[3],[2],[1]

-> [5], [4], [3], [2], [1]이고

차례대로 병합을 진행하면

첫 병합은 [4,5],[2,3],[1]이 되고

다음 병합에서 [4,5], [1,2,3]이 되고

마지막 병합에서 [1,2,3,4,5]가 된다.

### 슈도코드 작성

```java
public static void main(){
    int N  : 크기 받기
    int []arr : 정렬할 숫자가 저장될 크기 N의 배열
    mergeSort(arr, 0, arr.length);
    정렬 된 배열 출력
}

public void mergeSort(int [] arr, int start, int end){
    if(end - start < 2){
        return;
    }
    int mid = (start+mid)/2; : 중간 값 정하기
    mergeSort(arr, start, mid)  : 좌측 영역 분할 진행
    mergeSort(arr, mid, end) : 우측 영역 분할 진행
    merge(arr, start, mid, end) : 양측 영역 정복 진행
    
}

public void merge(int [] arr, int start, int mid, int end){
    int [] temp : 정렬된 원소를 저장할 크기 end - start 의 임시배열
    int l1 : 왼쪽 영역 시작 인덱스
    int l2 : 오른쪽 영역 시작 인덱스
    int t = 0 : 임시배열 포인터

    while(l1 < mid && l2 < end){
        양쪽 포인터가 가리키는 값중 
        더 작은값을 임시배열에 넣고
        해당 포인터를 한칸 오른쪽으로 늘려준다.
        물론 임시배열포인터도 같이 늘려주어야 한다.
    }

    while(l1<mid){
        왼쪽 영역에 포인터가 끝까지 이동하지 못했을 경우
        즉, 값이 남아있는 경우 임시배열에 넣어준다.
    }

    while(l2<end){
        오른쪽 영역에 포인터가 끝까지 이동하지 못했을 경우
        즉, 값이 남아있는 경우 임시배열에 넣어준다.
    }

    for(int i = start; i<end;i++){
        임시배열의 값을 하나씩 원본배열에 넣어준다.
    }
}
```




