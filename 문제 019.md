## k번째 수 구하기

문제

수 N개 A1, A2, ..., AN이 주어진다. 

A를 오름차순 정렬했을 때, 

앞에서부터 K번째 있는 수를 구하는 프로그램을 작성하시오.

입력

첫째 줄에 N(1 ≤ N ≤ 5,000,000)과 K (1 ≤ K ≤ N)이 주어진다.

둘째에는 A1, A2, ..., AN이 주어진다. (-10^9 ≤ Ai ≤ 10^9)

출력

A를 정렬했을 때, 앞에서부터 K번째 있는 수를 출력한다.

### 문제 분석하기

N이 5백만이므로 O(nlogn) 정렬방식을 사용하여 정렬 하고

k 번째 수를 출력하면 된다.

숫자의 최대값이 10억이므로 정렬할 때 int 자료형이면 충분하지 싶다.

k의 범위가 1~N이라는점이고 실제 수의 배열이 0번째 부터 시작하는걸 1로 두기 때문에

k-1이 실제 배열상 구해야하는 순번임을 조심해야 한다.

nlogn의 방식인 퀵 정렬로 문제를 해결 해 본다.

일반적인 퀵정렬보다도

정렬 하면서 얻은 left pointer 와 right pointer 를 가지고

정렬이 완료된 위치의 순번이 찾으려는 k번째 수 라면

정렬을 더 이상 할 필요가 없다.

### 손으로 풀어보기

먼저 N = 5, K = 2, 숫자는 4 1 2 3 5로 주어졌다고 가정한다.

첫번째 페이즈 :

왼쪽 포인터는 인덱스 0(4), 오른쪽 포인터는 인덱스 4(5)를 가리키고

미드값을 인덱스를 2(2)로 두었을때 파티션 분리를 하면

왼쪽 포인터는 0(4), 오른쪽 포인터는 2(2)를 가리키게 된다.

오른쪽 포인터가 여전히 오른쪽에 있으므로 swap을 진행한다.

swap진행 후 : 

배열 : 2 1 4 3 5

왼쪽 포인터 1(1), 오른쪽 포인터는1(1)

양쪽 포인터 값이 현재 같으므로 현재의 분할을 종료하고

왼쪽 포인터와 오른쪽 포인터가 같고, 결국 k-1번째를 가리키고 있다면 

배열의 원소를 출력하고 정렬을 종료한다.

만약에 오른쪽 포인터 < 왼쪽 포인터 가 되고, pl-1번째가 k-1번째를 가리키고 있다면

배열의 원소를 출력하고 정렬을 종료한다.

어느것도 해당되지 않는다면 추가적인 퀵소트를 진행한다.

내려왔엇던 오른쪽 포인터가 아직은 시작지점만큼 내려오진 않았으므로 (pr>start)

start~pr(0~1)범위에 퀵소트를 진행한다.

올라왔엇던 왼쪽 포인터가 아직은 끝지점까지 올라오진 않았으므로 (pl<end)

pl~end(1~4) 범위에 퀵소트를 진행한다.


### 슈도 코드 작성
```java
int N : 크기 N 받아오기
int K : 찾아야할 원소순번 (사용할 때에는 K-1)
int []num = new int[N] : 정렬해야할 크기 N의 배열

public void quickSort(배열, 시작지점, 끝지점, 찾아야할 인덱스번호){
    int mid : 중간지점 값(임시피벗)

    int rightStartNumber = partition(arr,start,end ) : 새로 분할 할 오른쪽 시작지점 인덱스번호
    
    if(start < rightStartNumber-1) quickSort(배열, start, rightStartNumber-1) :

    오른쪽 시작지점 - 1은 곧 왼쪽 영역 끝지점이기 때문에

    왼쪽영역 끝지점이 아직 시작지점보다 크다면 정렬 할 원소가 남아있다고 판단한다.

    if(rightStartNumber < end) quickSort(배열, rightStartNumber, end)

    위의 if문도 마찬가지

}

public void swap(배열, 인덱스1, 인덱스2){
    배열의 인덱스1번원소와 2번원소를 교체한다.
}

public static void main(){
    메인함수에서 quickSort호출
    정렬된 배열에서 K-1번째 출력
}
```
