## 주몽의 명령

문제

주몽은 철기군을 양성하기 위한 프로젝트에 나섰다. 

그래서 야철대장을 통해 철기군이 입을 갑옷을 만들게 하였다. 

야철대장은 주몽의 명에 따르기 위하여 연구에 착수하던 중 아래와 같은 사실을 발견하게 되었다.

갑옷을 만드는 재료들은 각각 고유한 번호를 가지고 있다. 

갑옷은 두 개의 재료로 만드는데 

두 재료의 고유한 번호를 합쳐서 M(1 ≤ M ≤ 10,000,000)이 되면 갑옷이 만들어 지게 된다. 

야철대장은 자신이 만들고 있는 재료를 가지고 갑옷을 몇 개나 만들 수 있는지 궁금해졌다. 

이러한 궁금증을 풀어 주기 위하여 N(1 ≤ N ≤ 15,000) 개의 재료와 M이 주어졌을 때 

몇 개의 갑옷을 만들 수 있는지를 구하는 프로그램을 작성하시오.

입력

첫째 줄에는 재료의 개수 N(1 ≤ N ≤ 15,000)이 주어진다. 

그리고 두 번째 줄에는 갑옷을 만드는데 필요한 수 M(1 ≤ M ≤ 10,000,000) 주어진다. 

그리고 마지막으로 셋째 줄에는 N개의 재료들이 가진 고유한 번호들이 공백을 사이에 두고 주어진다. 고

유한 번호는 100,000보다 작거나 같은 자연수이다.

출력

첫째 줄에 갑옷을 만들 수 있는 개수를 출력한다.

### 문제 분석

시간제한은 2억 연산횟수를 가지고 있지만

M의 크기가 1000만이고 숫자의 개수가 15000개 이므로 최소한의 반복문 횟수로 문제를 해결해야 한다.

연속된 숫자는 아니지만 숫자 두개를 조합하여 M을 만들어야 하므로

투포인터 알고리즘을 사용하여 해결 할 수 있다.

여기서 투포인터 알고리즘을 사용하려면

정렬을 해야하는데 그 개수가 15000개면 nlogn을 사용하여 정렬해도 문제가 없을 것이다.

일반적인 라이브러리에서 제공하는 정렬 알고리즘의 시간복잡도에 해당하므로

정렬 후 포인터를 양쪽 끝에두고 시작한다.

포인터를 양쪽끝에 두는 이유는 비 연속적인 숫자이며 2개의 숫자들만 원하므로

만약에 둘다 시작지점에서 하나씩 오른쪽으로 범위를 늘려가는 방식을 택한다면

start 포인터를 늘렸을때 end포인터가 같이 따라와야하는 오버헤드가 생긴다.

따라서 양쪽끝에 두는것을 채택한다.

포인터 이동 규칙은

만약 현재의 합이 M과 같다면 

카운팅 하고 

start 는 늘리고 

end 는 줄여야한다.

M보다 크다면 

end 줄인다.

M보다 작다면 

start를 늘린다.

종료조건은 end 포인터가 start 포인터보다 작으면 된다.

### 손으로 풀기

N = 6, M = 9, 숫자배열 = [2 7 4 1 5 3]으로 주어지면

정렬후 

1 2 3 4 5 7이 된다.

여기서 젤 처음엔 start 1이고 end 가 7 이므로 M보다 작게 된다

따라서 start 포인터가 오른쪽으로 한칸 이동한다

이 다음은 start 2이고 end 가 7 이므로 M과 같아지게 된다.

따라서 start 포인터가 오른쪽으로 한칸, end포인터가 왼쪽으로 한칸 이동한다.

이 다음은 start가 3이고 end가 5이므로 M보다 작게 된다

따라서 start 포인터가 오른쪽으로 한칸 이동한다.

이 다음은 start가 4이고 end가 5이므로 M과 같아져서 

start 포인터가 오른쪽으로 한칸 end포인터가 왼쪽으로 한칸 이동한다.

그러면 결국 start>end 가 되므로 반복문이 종료된다.

### 슈도코드 작성
```java
int N
int c
int M

int start = 0;
int end = N-1;

int [] num

for i 0~N:
    num에 문자열-> 정수형으로 바꿔서 배열저장

while (start>end){
    if(시작지점 값 + 끝지점 값 == M){
        시작지점 ++
        끝지점 --
        c++
    }
    else if(시작지점 값 + 끝지점 값 > M){
        끝지점 --
    }else{
        시작지점 ++
    }
}
```



