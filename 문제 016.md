## 버블 소트

문제

버블 소트 알고리즘을 다음과 같이 C++로 작성했다.
```C++
bool changed = false;
for (int i=1; i<=N+1; i++) {
    changed = false;
    for (int j=1; j<=N-i; j++) {
        if (A[j] > A[j+1]) {
            changed = true;
            swap(A[j], A[j+1]);
        }
    }
    if (changed == false) {
        cout << i << '\n';
        break;
    }
}
```
위 소스에서 N은 배열의 크기이고, 

A는 정렬해야 하는 배열이다. 

배열은 A[1]부터 사용한다.

위와 같은 소스를 실행시켰을 때, 

어떤 값이 출력되는지 구해보자.

입력

첫째 줄에 N이 주어진다. 

N은 500,000보다 작거나 같은 자연수이다. 

둘째 줄부터 N개의 줄에 A[1]부터 A[N]까지 하나씩 주어진다. 

A에 들어있는 수는 1,000,000보다 작거나 같은 자연수 또는 0이다.

출력

정답을 출력한다.

### 문제분석

시간제한이 2초라서

최대 50만 크기의 배열을 기본적인 버블정렬 하는것은 시간초과가 되어 버린다.

문제에서는 버블정렬을 사용한 C++코드로 보여지는데

버블정렬 기준으로 swap을 전혀 진행하지 않은 loop가 몇번째가 있느냐 이다.

즉, swap을 진행하지 않는 구간이 생긴다는 것 은

해당 구간은 이미 정렬된 상태 라는 점이다.

일반적인 라이브러리에서 제공되는

정렬 알고리즘의 시간복잡도는 O(nlogn)이다.

핵심은 

버블정렬이 일어날 때에는

인접한 원소끼리 swap이 일어나고

이 때 더 큰원소가 오른쪽으로 가게 된다.

루프 한번당 특정 원소가 오른쪽으로 가는 횟수는 여러번 나올 수 있지만

왼쪽으로 이동하는 횟수는 무조건 한번이다.

즉, 여러 루프를 돌았을 때 가장 많이 왼쪽으로 이동한 횟수의 최대값에 + 1한 값이 정답이 된다.

왜 여기서 +1을 해 주 나면

왼쪽으로 이동한 횟수 도 있지만

문제상에 C++코드를 보면 결국

마지막 정렬이 다 되었을 때의 반복도 결과값에 포함되기 때문이다.

그래서 정렬하기 전 인덱스와 정렬 한 후 인덱스를 비교하고 

그 차 중 가장 큰 값을 결정한 후 +1 하여 출력한다.

### Comparable Interface

우리가 일반적으로 정렬을 수행 할 때에는

배열의 경우 ```Arrays.sort```를, 다른 ```Collections```의 경우 ```Collections.sort``` 통해 진행한다.

이러한 sort() 메서드를 정의하는 인터페이스를 ```Comparable``` 인터페이스 라고 한다.

#### 구현방법

정렬 할 객체의 ```Comparable``` 인터페이스를 ```implements```하고 ```compareTo``` 메서드를 구현하면 된다.

```compareTo``` 메서드는 좌측 파라미터가 더 크면 양수, 같으면 0 그리고 우측 파라미터가 더 크면 음수를 리턴한다.

주의 할 점은

원시 타입의 배열에선 적용이 불가능하다는 점이다.

### Comparator Interface

정렬 가능한 클래스들의 기본 정렬 기준과 다르게 정렬 하고 싶을 때 사용하는 인터페이스 이다.

주로 익명 클래스로 사용된다.

#### 구현방법

```Comparator``` 인터페이스를 ```implements``` 한 후 ```compare``` 메소드를 오버라이드 한 ```myComparatorClass```를 정의한다.

```Comparable``` 인터페이스의 ```compareTo``` 메소드와 마찬가지로 

좌측 파라미터가 더 크면 양수, 같으면 0 그리고 우측 파라미터가 더 크면 음수를 리턴 하면된다.

이렇게 구현한 ```comparator``` 객체를 sort함수 두번째 인자로 넘겨주면 된다.

wrapper 클래스에서 바로 compare 메서드를 호출 할 경우

우측 파라미터와 좌측 파라미터의 위치를 바꾸면 내림차순 정렬이 된다.

### 손으로 풀어보기

처음에 

정렬 후 인덱스번호는

당연히 1 2 3 4 5 이고

정렬 전 인덱스번호는 Comparable 인터페이스를 통해 구하면

2 4 5 3 1 이 된다.

여기서 각 데이터 별 차를 구하면

1 2 2 -1 4 가 된다.

여기서 최대값은 2인데 정렬 다 됬을 때 에도

반복문을 수행 하는 경우를 더하여 3이 정답이 된다.

### 슈도 코드
```
Comparable 인터페이스를 구현한

인덱스와 값을 가지고 있는 클래스 정의

메인 클래스 :
    메인함수 {
        주어진 숫자들을 Comparable 인터페이스를 구현한 클래스에 넣어둠
        
        int max = 0 : 차의 최대값 구하는 용도

        그리고 Arrays.sort 실행

        for(i = 0 ~ N){
            if(max > 정렬 전 인덱스 - 정렬 후 인덱스){
                max = 두 인덱스의 차
            }
        }

        System.out.println(max+1)
        
    }

```




