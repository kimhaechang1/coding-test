## 위상정렬

위상정렬은 조건이 딱 정해져 있다.

순환이 없으면 위상정렬이 가능하다.

왜냐하면 위상정렬의 기본 메커니즘은, 리프(트리에서 루트)노드들 부터 차근차근 간선들을 짤라가는것 이기 때문이다.

즉, 노드들을 그래프 방향 순서대로 나열하는것을 위상정렬이라고 한다.

또한 위상정렬을 통해 사이클 판별도 가능하다.

### 위상정렬의 구현

<a href="https://ko.wikipedia.org/wiki/%EC%9C%84%EC%83%81%EC%A0%95%EB%A0%AC">위상정렬 위키</a>

모든 노드들에 대해서 자신으로 들어오는 간선(차수)를 셈한다.

여기서 리프노드를 알 수 있는데, 만약 무방향 (양방향) 그래프라면 리프노드는 간선(차수) 이 하나인 걸 찾으면 된다.

방향있는 그래프라면 자신에게 들어오는 차수가 (간선)이 0인 노드를 리프노드로 찾으면 된다.

해당 노드들로부터 탐색하면서, 해당 간선을 지워나가면서 해당 노드로 타고 들어오는 간선을 가진 모든 노드의 차수를 discount 한다.

즉, 해당 리프노드의 인접노드의 차수 카운트를 내린다는 것이다.

이렇게 하는 이유는 리프노드들을 현재 순서상 동일 순번의 노드로 지칭하기 때문이다.

그래서 간선을 다짜르고 보면 더이상 짜를 노드가 없어서 다음 노드로 가야하는 순간이 있다. 이것이 바로 위에서 했던 리프노드를 찾는조건과 동일한 노드를 처리대상으로 삼는다.

### 수도 코드

간선의 개수가 N개인 DAG에 대하여 위상정렬을 수행하시오

단 DAG는 인접리스트로 되어 있다.

```
g -> DAG graph // 방향 비순환 그래프 저장용 
int[] indegree // 진입차수 저장
edges // 모든 그래프 차수
bool[] v // 방문체크
Queue

for edge in range edges:
  indegree[edge.end]++;

for node, indgree in indegree:
  if indegree[node] == 1:
    v[node] = true;
    queue.push(node)


Queue:
  queue -> get node
  for end in g[node]:
    indegree[end]--
    if (indegree[end] == 1) :
        v[end] = true
        queue.push(end)
```
