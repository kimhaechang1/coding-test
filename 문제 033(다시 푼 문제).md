## 카드 정렬하기

문제

정렬된 두 묶음의 숫자 카드가 있다고 하자. 

각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. 

이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.

매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 

이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 

예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 

합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다. 

그러나 10장과 40장을 합친 뒤, 

합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.

N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 

최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 

이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 

숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.

출력

첫째 줄에 최소 비교 횟수를 출력한다.

### 문제 분석하기

정렬된 두 묶음의 숫자카드

각묶음수 A개 B개, 합칠라면 A+B번의 비교 필요

고르는 순서에 따라 비교횟수가 달라짐

10 20 40 -> (10+20) + (30+40) 으로 총 100번의 비교가 필요하고

10 40 20 순서면 -> (10+40) + (50+20)으로 총 120번의 비교가 필요하게된다.

최소 비교를 구해야 한다.

먼저 10만개의 숫자 묶음을 정렬한다고 하면

NlogN의 시간복잡도가 든다.

그리고 무조건 두 묶음 씩 이므로

가장 작은 숫자부터 차례대로 묶어서 비교했을 경우가 항상 최소가 된다. 라고 가정

예를들어 숫자가 10 20 30 50 일때

(10+20) + (30+30)+ (60+50) = 30 + 60 + 110 = 200회

(10 + 30) + (40 + 50) + (90 + 20) = 40 + 90 + 110 = 240회

해당 가정으로 코드 작성

### 손으로 풀어보기

입력된 숫자가 10 20 40 이면

정렬 후 합배열을 구하고

합배열을 구했을때 10 30 70 이 되고

원소의 합을 1번부터 구하게 되면 정답이 된다.

### 슈도코드 작성

```JAVA
main(){
    int n : 묶음의 개수
    int [] cards : 묶음별 카드 개수
    int [] S : 합배열 (cards.length+1)
    sort(cards) 
    int sum = 0;
    for(int i : 1~S.length){
        합배열 구하기
        sum+=S[i];
    }    
    System.out.println(sum);
}
```

### 다시 문제 분석하기

그대로 낮은 순서대로가 아닌

가장 작은 숫자와 그 다음 숫자 두개를 뽑아서

횟수를 저장하고 묶음이 된 크기보다 크거나 같은 숫자하나를

다시 또 뽑아서 횟수를 저장하고 이런식으로 가야지 최소가 된다.

그대로 다 순서대로 묶는것이 아닌 그때마다의 최소의 묶음을 꺼내야한다

그야말로 살살 더해야 한다!

### 슈도코드 작성
```java
main(){
    int n : 묶음의 개수
    ArrayList<Integer> cards : 묶음별 카드 개수
    int sum : 횟수 저장 할 변수
    Collections.sort(cards) : 묶음 정렬
    while(cards.size() != 0){
        0번이랑 1번을 뽑아서 더한값을 sum에 축적 하고
        0번이랑 1번을 삭제하고
        그 더한값을 cards에 넣고 
        다시한번 정렬
    }
    
}
```

### 시간 초과로 인해 다시풀기

카드 묶음을 저장하고 꺼내면서 정렬된 순서로 꺼낼 수 있는

우선순위 큐를 활용한다

우선순위 큐는 힙 규칙을 따르면서 기본적으로 오름차순 정렬 형태로 출력하기 때문에

시간에서 앞서게 된다.

ArrayList는 정렬 후 원소를 삭제해주는 연산과 삽입 연산에서 패널티가 심하므로 시간 초과가 나게 되었다.

### 슈도코드 작성

```java
main(){
    int n : 묶음의 개수
    PriorityQueue<Integer> pq : 묶음별 카드개수 저장
    int sum : 횟수 누적용
    while(pq.size()>1){
        int c = (pq.poll()+pq.poll());
        sum+=c;
        pq.add(c);
    }
    System.out.println(sum)
}
```