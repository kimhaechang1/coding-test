## 이진탐색 

이진탐색은 데이터가 **정렬**돼 있는 상태에서 원하는 값을 찾아내는 알고리즘

대상 데이터의 중앙값과 찾고자 하는 값을 비교해 

데이터의 크기를 절반씩 줄이면서 대상을 찾는다.

이진탐색은 정렬 데이터에서 원하는 데이터를 탐색할 때 사용하는 가장 일반적인 알고리즘

구현 및 원리가 비교적 간단하기 때문에

코딩테스트에서는 부분 문제로 요구하는 영역이다.

시간복잡도는 O(logN)이다.

### 이진 탐색의 핵심이론

이진 탐색은 오름차순으로 정렬된 데이터에서 다음 4가지의 과정을 반복

-> 만약 내림차순이라면 조건을 반대로하여 과정을 반복하면 됨

1. 현재 데이터셋의 중앙값을 선택한다.

2. 중앙값 > 타깃 데이터 라면 중앙값 기준으로 왼쪽 데이터 셋을 고른다.

3. 중앙값 < 타깃 데이터 라면 중앙값 기준 오른쪽 데이터 셋을 고른다.

4. 과정 1~3을 반복하고 중앙값 == 타깃 데이터 일 때 탐색을 종료한다.

### 이진탐색 예시

총 16개의 데이터가 있는 데이터셋에 값이 55인 데이터를 찾는다면?

3 7 13 15 23 35 38 41 46 49 55 67 68 72 77 86

중앙값을 41로 선택

41 < 55 이므로 오른쪽 데이터 셋으로 감

46 49 55 67 68 72 77 86 

중앙값을 67로 선택

67 > 55 이므로 왼쪽 데이터셋으로 감

46 49 55

중앙값을 49로 선택

49 < 55 이므로 오른쪽 데이터셋으로 감

55

중앙값 55로 선택

55 == 55 로 중앙값과 타깃데이터가 같으므로 탐색 종료

총 4번의 탐색으로 원하는 데이터를 찾을 수 있엇음

### 이진탐색의 UpperBound 와 LowerBound

이진탐색의 기본 알고리즘은 중복이 없으며, 반드시 존재하는 데이터를 탐색할 때 용이하다.

여기서 최종탐색할 숫자가 중복하지 않은경우와

중복되어 나오는경우로 나뉘는데

이 때 LowerBound의 경우엔 일치하는 숫자가 처음 나타나는 시점을 구할 수 있고

UpperBound의 경우엔 일치하는 숫자 다음 수가 나타나는 지점을 구할 수 있다.

따라서 LowerBoundIndex <= 찾고자 하는 수< UpperBoundIndex 라고 생각하고

UpperBound(n) - LowerBound(n) 을 하게 되면 해당 정렬된 데이터 속에서

숫자 n이 몇개 있는지 파악할 수 있게 된다.

이진탐색의 기본형

```java
// 정렬 된 주어진 배열
static int[] arr = { 0, 1, 2, 2, 3, 4 };
```

```java
int binarySearch(int n){
    int l = 0;
    int r = arr.length - 1;
    int mid = 0;
    while(l<=r){
        mid = (l+r)/2;
        if(arr[mid] == n){
            // 찾고자 하는수가 미드 값과 동일하다면
            // 찾고자 하는 수의 위치를 찾은것 이므로
            // index를 리턴
            return mid;
        }else if(arr[mid]<n){
            // 찾고자 하는 수가 더 크면 오른쪽 영역에서 재탐색
            l = mid + 1;
        }else{
            r = mid - 1;
        }
    }
    return mid;
}
```

중복된 수가 존재하지 않거나 존재하는 배열에서 

특정수가 최초로 혹은 최소가 되는 수일 때의 위치를 구하려면

LowerBound BinarySearch를 진행

```java
static int lower(int s, int e, int target) {
        // 하한경계이고
        // 더 내려갈 수 없는 값을 정해놓는다.
        // 중요한 지점은 이것보다 큰값 혹은 같은 값이 여러개 있을 수 있으므로
        // 중앙 값과 같은 경우에서도 mid - 1을 건다.
        // 같은것 조차 더 큰값으로 취급하므로 상한경계가 바뀔때마다 갱신
        int left = s;                         
        int right = e;                     
        int minIdx = n;  // 여기 까먹으면 안됨 항상 최대보다 더 큰 idx로 잡아줘야함                     
        while (left <= right) {               
            int mid = (left + right) / 2;     
            if(points[mid] >= target) {       
                right = mid - 1;              
                minIdx = Math.min(minIdx, mid);
            }
            else                               
                left = mid + 1;                
        }

        return minIdx;                         
    }
```

중복된 수가 존재하지 않거나 존재하는 배열에서

특정수가 다음 수로 바뀌기 직전의 위치를 구하려면

결국 위의 lowerbound와 달라지는 점은 같은값을 크다에 포함시키냐 작다에 포함시키냐 차이 뿐이다.

항상 상한경계 값이 달라질때마다 리턴할 minIdx를 갱신해야한다.

UpperBound BinarySearch를 진행

```java
static int upper(int s, int e, int target){
        // 상한 경계 : 처음으로 값이 더커질때의 idx
        // 중앙 값 보다 작거나 같은 값이 여러개 있을 수 있다.
        // 따라서 같은것들 조차 낮은값으로 취급하고
        // 상한 경계가 바뀔때마다 갱신
        int left = s;
        int right = e;
        int minIdx = n; // 여기 까먹으면 안됨 항상 최대보다 더 큰 idx로 잡아줘야함
        while(left <= right){
            int mid = (left + right) / 2;
            if(points[mid] > target){
                right = mid - 1;
                minIdx = Math.min(minIdx, mid);
            }else{
                left = mid + 1;
            }
        }
        return minIdx;
    }
```
### 이진탐색에서의 나의 결론

1. 이진탐색을 사용하기 전 꼭 주어진 배열이 **정렬된 배열**인지 파악 할 것

2. 정렬된 배열 혹은 특정 범위의 수에서 어떤 조건에 맞는 수 혹은 수의 위치를 구할때 사용

3. 정렬된 배열 내 원소가 **절대 중복될 수 없다**면 일반적인 이진탐색 사용

    - 일반적인 이진탐색 할 때, ```while``` 범위 ```(l<=r)```임을 잊지 말것

4. 정렬된 배열 내 원소가 중복될 가능성이 있다면 UpperBound 혹은 LowerBound사용

    - "최초로 등장" 혹은 "최소가 되는 수"라는 조건이 붙어있으면 LowerBound 진행

    - "최초로 바뀌는" 혹은 "최대가 되는 번수"라는 조건이 붙어있으면 UpperBound 진행

    - 중복이 존재하여 LowerBound나 UpperBound를 진행 할 때 ```while``` 조건과 영역 나눌때 조건 잘 파악하기

    - UpperBound 와 LowerBound는 r값이 리턴되어야 한다
    
        - LowerBound : mid값 보다 작은 조건에서 mid값을 조건에 포함
        - UpperBound : mid값 보다 큰 조건에서 mid값을 조건에 포함



