## 벨만 포드

음수 가중치가 존재하는 그래프 내에서 최단거리를 구하려고 할 때,

일반적인 최단거리 알고리즘인 다익스트라를 사용하여 해결하려 하면, 음수 가중치로 인해 무한정 cost 배열의 값을 낮출 수 있는 음의 사이클이 존재할 수 있다.

이러한 경우 벨만-포드 알고리즘을 통해 처리할 수 있다.

### 작동 원리

벨만-포드 알고리즘은 모든 간선을 사용해서 음수 사이클 유무를 판단하게 된다.

어떤 N개의 정점이 존재하는 그래프내에 경로에 대해서 최단거리를 정의한다고 했을 때, 

최단경로의 최대 간선개수는 N - 1개여야 한다.

또한 최단경로를 계산할 때 기본적으로 모든 정점은 한 번만 방문하게 된다.

따라서 간선을 전부 순회하면서 간선 내 끝점을 기준으로는 한 번만 방문하면서 갱신될 것이고,

그렇게 갱신되는 경로상의 총 Cost는 다른 간선들에 의해 최대 N - 1번 갱신될 수 있다.

### 코드

크게 두 가지 방식이 있다.

1. 특정 출발점으로 부터 시작하여 음수 경로가 있는지 파악하는 방법
```java
그래프 내의 모든 정점의 개수를 N이라고 하고
그래프의 모든 간선을 Edge 라고 했을 때
int[] cost = { INF, } // COST 배열 INF 로 초기화
boolean isUpdate = false; // 더 이상 업데이트가 발생하지 않는 경우 stop
cost[startNode] = 0; // 시작 정점에서 가중치 0인 값으로 출발
for(1... N - 1) {
  isUpdate = false;
  for(Edge edge) {
    if (cost[edge.s] != INF && cost[edge.e] > cost[edge.s] + edge.c) {
        isUpdate = true;
        cost[edge.e] = cost[edge.s] + edge.c
    }    
  }
  if (not isUpdate) {
    // 더 이상 업데이트가 없으면 끝까지 수행할 필요 없음
    break;
  }
}

// 여기서 한번 더 수행이 된다면, 음수 사이클이 발생하는것
// 왜냐하면 최단경로 내 간선은 많아봐야 N - 1개 이기 때문
// 또한 마지막 N - 1 번째에도 업데이트가 발생했을때만 돌릴것
if (isUpdate) {
  for(Edge edge) {
     if (cost[edge.s] != INF && cost[edge.e] > cost[edge.s] + edge.c) {
        시작점 startNode에서 적어도 하나의 경로는 음수 사이클을 발생시킨다.
        break;
    } 
  }
}
```

2. 모든 정점이 연결되어 있단 보장이 없고, 그래프 내에 음수 사이클 존재만 파악하는 경우

만약 모든 그래프가 연결되어있다는 보장이 없다면,,

이 방식에서는 INF 검사를 수행하지 않아도 된다.

원래는 특정 출발점 노드에서 애초에 도달 불가능한 노드를 구분지었어야 했지만, 

어짜피 음수 사이클만 파악하는 경우 한번 더 업데이트가 발생하는지가 중요하다.

따라서 위의 코드에서 INF 검사를 없애면 된다.


