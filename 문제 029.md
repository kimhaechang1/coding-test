## 원하는 정수 찾기

문제

N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 

이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.

입력

첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 

다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 

다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 

이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -2^31 보다 크거나 같고 2^31보다 작다.

출력

M개의 줄에 답을 출력한다. 

존재하면 1을, 존재하지 않으면 0을 출력한다.

### 문제 분석하기

시간제한이 2초이므로  2억번의 연산내외로 해결해야 한다.

최악의 상황일때 수의 개수 10만개이고 찾아야하는 수 10만개 이면

이미 시간제한을 초과하게 된다.

10만개의 수를 찾는데 있어서 N^2이 아닌 알고리즘을 통해 수 탐색을 이뤄야 한다.

주어진 숫자들을 정렬하는 알고리즘을 수행하면 NlogN의 수행으로 정렬하고

찾고자 하는수를 기준으로 반복문을 돌면서 탐색 함수를 수행하는데

탐색함수로 이진탐색을 수행하게 된다면 N * logN으로 시간제한 내에 해결할 수 있다.

### 손으로 풀어보기

데이터가 5개로 4 1 5 2 3으로 주어지고 찾아야할 수가 5개로 1 3 7 9 5 로 주어졌을때

먼저 주어진 데이터셋을 정렬합니다.

1 2 3 4 5

첫번째 수 1을 이진탐색을 통해 찾는다.

먼저 중간값((원소 시작점 + 끝 번호)/2)을 찾고 중간값보다 작기 때문에 왼쪽 데이터 셋에서 고른다.

왼쪽 데이터셋 범위는 시작점 ~ 중간값-1 로 정하고 

다시 중간값을 찾으면  = 0번이고 0번원소는 찾으려는 수와 같으므로 원소 찾기 성공한다.

나머지 찾아야할 수도 위의 행동을 반복한다.

### 슈도 코드 작성

```java
main(){
    int N : 데이터셋 개수
    int [] num : 데이터들이 들어가있는 배열
    int m : 찾아야하는 데이터 개수
    int [] mum : 찾아야하는 데이터들이 들어있는 배열

    for(int k : mum){
        int s = 0;
        int e = num.length - 1;
        int find = k;
        int flag = 0;
        while(s<=e){
            int mid = num[(s+e)/2];
            int midIndex = (s+e)/2;
            if(mid == find){
               flag =1 ; 
            }
            else if(mid < find){
                s = midIndex+1;
            }else{
                e = midIndex-1;
            }
        }
        flag 출력
    }
}
```

