## 원하는 정수 찾기

문제

N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 

이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.

입력

첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 

다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 

다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 

이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -2^31 보다 크거나 같고 2^31보다 작다.

출력

M개의 줄에 답을 출력한다. 

존재하면 1을, 존재하지 않으면 0을 출력한다.

### 문제 분석하기

시간제한이 2초이므로  2억번의 연산내외로 해결해야 한다.

최악의 상황일때 수의 개수 10만개이고 찾아야하는 수 10만개 이면

이미 시간제한을 초과하게 된다.

10만개의 수를 찾는데 있어서 N^2이 아닌 알고리즘을 통해 수 탐색을 이뤄야 한다.

주어진 숫자들을 정렬하는 알고리즘을 수행하면 NlogN의 수행으로 정렬하고

찾고자 하는수를 기준으로 반복문을 돌면서 탐색 함수를 수행하는데

탐색함수로 이진탐색을 수행하게 된다면 N * logN으로 시간제한 내에 해결할 수 있다.

정렬된 배열에서 특정 수의 위치를 찾는 걸로서

일반적인 이진탐색으로 해결 할 수 있다.

### 손으로 풀어보기

데이터가 5개로 4 1 5 2 3으로 주어지고 찾아야할 수가 5개로 1 3 7 9 5 로 주어졌을때

먼저 주어진 데이터셋을 정렬합니다.

1 2 3 4 5

첫번째 수 1을 이진탐색을 통해 찾는다.

먼저 중간값((원소 시작점 + 끝 번호)/2)을 찾고 중간값보다 작기 때문에 왼쪽 데이터 셋에서 고른다.

왼쪽 데이터셋 범위는 시작점 ~ 중간값-1 로 정하고 

다시 중간값을 찾으면  = 0번이고 0번원소는 찾으려는 수와 같으므로 원소 찾기 성공한다.

나머지 찾아야할 수도 위의 행동을 반복한다.

### 슈도 코드 작성

```java

static int [] ns : 데이터 셋 배열

boolean binarySearch(int find){
    int l = 0;
    int r = ns.length - 1;
    int mid = 0;
    while(l <= r){
        mid = (l+r)/2;
        if(ns[mid] == find){
            return true;
        }else if(ns[mid] < find){
            l = mid + 1;
        }else{
            r = mid - 1;
        }
    }
    return false;
}
main(){
    int n : 데이터셋의 개수
    StringBuilder sb; : 출력을 위한 인스턴스
    int m : 찾아야 하는 수의 개수
    int [] ms : 찾아야 하는 수 배열
    
    for(int find : ms){
        원소를 하나씩 꺼내어 이진탐색을 실행
        if(binarySearch(find)){
            sb.append("1").append("\n");
        }else{
            sb.append("0").append("\n");
        }
    }
    System.out.println(sb);
}
```

