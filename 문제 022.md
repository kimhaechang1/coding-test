## 수 정렬하기 3

문제

N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.

입력

첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다. 

둘째 줄부터 N개의 줄에는 수가 주어진다. 

이 수는 10,000보다 작거나 같은 자연수이다.

출력

첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

### 문제 분석하기

시간제한이 5초이므로 5억번의 연산안에 해결해야한다.

하지만 수의 개수가 터무니 없이 크므로 nlogn의 연산에서도 해결 하기 힘들다

따라서 시간복잡도가 O(n)인 정렬을 사용해야 한다.

수의 크기가 최대 10000인 자연수이므로 기수정렬을 사용할 수 있다.

### 손으로 풀어보기

숫자의 개수가 10개이고, 5 2 3 1 4 2 3 5 1 7로 주어졌다고 가정한다.

1의 자리수에 대한 카운팅 배열을 구한다.

index  0,1,2,3,4,5,6,7,8,9

count [0,2,2,2,1,2,0,1,0,0]

이들에 대한 누적합 배열을 구한다.

count [0,2,4,6,7,9,9,10,10,10]

누적합 배열을 이용하여 원본 원소의 정렬 후 인덱스번호를 구하고 

임시배열에 채워준다.

예를들어 뒤에서부터 정렬을 이어나가는데 4번 인덱스와 3번인덱스의 경우를 살펴보자.

4번 인덱스에 해당하는 값은 4이고

4의 count배열에서의 값은 7이다.

이를 -1 한 값이 정렬된 배열 속 인덱스번호이므로

4는 6의 위치에 있어야 한다.

그리고 count배열에서 4에 해당하는 값을 하나 빼 준다.

3번 인덱스에 해당하는 값은 1이고

1의 count배열에서의 값은 2이다.

이를 -1 한 값이 정렬된 배열속 인덱스번호이므로

1은 1의 위치에 있어야 한다.

그리고 count배열에서 1에 해당하는 값을 하나 빼 준다.

### 슈도코드 작성
```java
int N : 원소의 개수 받기
int arr[] : 원소들을 배열로 저장
int max = 5 : 크기가 최대 1만이므로 자리수를 늘려가면 반복할 횟수는 5번이다.
int j = 1 : 자리수를 의미하며 시작은 일의 자리수부터
int cnt = 0 : 현재 몇번째 반복인지 카운팅
int []temp = new int[n] : 원소들이 정렬된 임시배열
while(cnt != max){
    int [] count = new int[10] : 카운팅 배열
    for(int i = 0;i<arr.length;i++){
        실제 원소들을 하나씩 꺼내면서 
        현재 j의 값에 따른 자리수에 대한 카운팅배열을 구한다.
    }

    for(int i = 0;i<count.length;i++){
        카운팅 배열을 그대로 사용하여 합배열로 만든다.
    }

    for(int i = 0; i<arr.length;i++){
        카운팅 합배열을 이용하여 임시배열에 정렬 된 원소들을 채워주고
        카운팅 합배열에 해당하는 원소를 -1 해준다.
    }

    for(int i = 0;i<arr.length;i++){
        원본배열에 임시배열원소들을 그대로 넣어준다.
    }
    
    자리수를 늘린다.
    cnt를 하나 늘린다.
}
```


