# 시간복잡도

알고리즘에서 시간복잡도는

주어진 문제를 해결하기 위한 연산 횟수를 말한다.

일반적으로 수행시간은 1억번의 연산을 1초의 시간으로 간주하여 예측

## 시간 복잡도의 유형

- 빅 오메가 : best case의 경우 연산횟수 표기법

- 빅 세타 : average case의 경우 연산횟수 표기법

- 빅 오 : worst case의 경우 연산횟수 표기법

아래의 예제의 경우

 - 빅 오메가 : best case 기준으로 for문을 돌리자마자 찾는 경우로, 시간복잡도는 1이다.

 - 빅 세타 : average case 기준으로 for문을 절반정도 돌리면 평균적인 값이 되므로, 시간복잡도는 N/2 이다.

 - 빅 오 : worst case 기준으로 for문을 전부 돌렸을 경우가 최악이므로, 시간복잡도는 N이다.

```java
public class timeComplexityExample1{
    public static void main(String[] args){
        int findNumber = (int)(Math.random()*100);
        for(int i= 0;i<100;i++){
            if(i==findNumber){
                System.out.println(i);
                break;
            }
        }
    }
}
```

## 코딩테스트에서의 시간복잡도

코딩테스트에서는 빅 오 표기법을 기준으로 수행시간을 계산하는 것이 좋다.

왜냐하면 응시자가 작성한 프로그램을 기준으로 다양한 테스트케이스를 통과해야만

합격으로 판단되기 때문

## 알고리즘 선택의 기준으로 사용하기

다음의 문제에서 시간복잡도에 따라 적절한 알고리즘을 선택 할 수 있어야 한다.

우선 버블정렬의 시간복잡도는 N^2 이고, 병합정렬은 n*log(n)임을 알고있다고 가정하자.

```
수 정렬하기

입력 : 1번째 줄에 수의 개수(1<=N<=1,000,000), 2번째 줄부터는 N개의 줄에 숫자가 주어진다.

이 수는 절댓값이 1,000,000 보다 작거나 같은 정수이다. 수는 중복되지 않는다.

출력 : 1번째 줄 부터 N개의 줄에 오름차순 정렬한 결과를 1줄에 1개씩 출력한다.
```

위의 문제를 분석하면

일단 시간제한이 2초이므로 2억번 이하의 연산횟수로 문제를 해결해야한다.

우리가 문제를 풀기위해 알고있는 알고리즘은 병합정렬과 버블정렬이므로

각각의 시간복잡도에 데이터개수를 대입하여 계산해보면

- 버블정렬 : 약 10억번

- 병합정렬 : 약 2천만번

의 결과가 나오고 병합정렬의 경우가 2억번이하의 연산횟수에 해당하므로

적합한 알고리즘이 된다.

### 시간복잡도의 도출기준

- 상수는 시간복잡도 계산에서 제외된다.

- 가장 많이 중첩된 반복문의 수행횟수가 시간 복잡도의 기준이 된다.



