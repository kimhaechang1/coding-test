## 제곱 ㄴㄴ 수

문제

어떤 정수 X가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 

그 수를 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. 

min과 max가 주어지면, min보다 크거나 같고, 

max보다 작거나 같은 제곱ㄴㄴ수가 몇 개 있는지 출력한다.

입력

첫째 줄에 두 정수 min과 max가 주어진다.

출력

첫째 줄에 min보다 크거나 같고, max보다 작거나 같은 제곱ㄴㄴ수의 개수를 출력한다.

### 문제 분석하기

즉 주어진 범위는 1~100만 까지로 판단해도 된다

왜냐하면 max의 범위가 min범위에 100만을 더한 값이므로

주어진 범위에서 제곱수의 배수들을 미리 제곱ㄴㄴ수가 아닌 수로 판별해놓고

범위내의 제곱ㄴㄴ 수를 찾으면 된다.

바깥 for문에서 정수의 제곱수를 하나 정해주면

안쪽 for 문에서 제곱수의 배수들 중에서 min~max범위 사이인 것들을 전부 전처리 해주면 되는데,

여기서 안쪽 for을 1부터 돌리면 문제에서 주어진 범위 밖의 수를 전처리 하게되어

시간초과가 이루어진다.

따라서 문제에서 주어진 범위에서 하려고 한다면 

제곱수를 최소범위에서 나누어 떨어지면 그 나눈 숫자부터 max범위까지 제곱수의 배수를 전처리해 주면 되고

만약에 나누어떨어지지 않는다면 +1 해준 숫자부터 배수들을 전처리하면 된다.

### 손으로 풀어보기

min = 1
max = 10

1 <= X <= 10

1 은 항상 제곱 ㄴㄴ 수로 포함

4, 8, 9 = 2^2*1, 2^2*2, 3^2*1

2, 3, 5, 6, 7, 10 => 7개

### 슈도코드 작성

```java
main(){
    long min : 최솟값 입력받기
    long max : 최대값 입력받기
    boolean [] isJegobnono = new boolean[max-min+1] : 제곱 ㄴㄴ 수 판별, true : 제곱ㄴㄴ가 아님, false : 제곱ㄴㄴ

    int count = 1 : 제곱 ㄴㄴ수의 개수 판별, 1을 항상 포함
    for(long i = 2~max){
        long powerNum = i*i;
        long start  = min%powerNum == 0 ? min/powerNum : min/powerNum+1;
        for(long k = start ~ max){
            isJegobnono[(int)(k*powerNum-min)] = true
        }
    }
    for(int i = 0~max-min+1){
        if(!isJegobnono) count++;
    }
    count 출력
}
```
하유수보


### 문제가 쉽지않았다

이 문제의 핵심 생각은 2가지 정도 있는것 같다.
 
1. max의 범위를 좁힐 수 있는가?

바깥쪽 for문의 경우 제곱수의 배수만 걸러내면 되므로

i = 2 부터 시작하지만 i*i<=MAX 가 true인 순간만 작동하게 만들면

결국 logN의 수행 동작을 갖게 된다.

또한 판별해야하는 boolean 배열의 크기를 max-min+1 이라는점을 캐치해야한다.

왜냐하면 max범위에서 양변에 min을 빼 주게 되면 1~100만이므로 이는

일반 배열로 나타낼 수 있다.

2. 내부 for문의 범위를 좁힐 수 있는가?

내부 for문의 역할을 우선 생각해야한다.

위 문제에서 제곱수의 배수들을 미리 걸러내어야 하므로

내부 for문은 k = 1 에서 부터 k * 제곱수 <=MAX 일 때 까지로 하면 된다고 생각할텐데

이는 무조건적으로 시간초과가 날 수 밖에 없다.

왜냐하면 예를들어 내가 현재 외부 for문은 2로 잡혀져 있는데,

min = 10, max = 20이라면 10보다 작은 제곱수의 배수들을 전처리 할 필요가 없어진다.

(위의 조건에서는 4, 8 의 경우가 해당된다)

따라서 배수의 시작숫자를 정해주어야 하는데,

이는 주어진 최솟값을 최대한 제곱수로 나누고 나누어 떨어진다면 그 몫부터 시작하면되고

나누어떨어지지 않는다면 범위보다 작다는 의미이므로 몫+1 부터 시작하면 된다.
