## 오큰수

크기가 N인 수열 A = A1, A2, ..., AN이 있다. 

수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. 

Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 

그러한 수가 없는 경우에 오큰수는 -1이다.

예를 들어, A = [3, 5, 2, 7]인 경우 

NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. 

A = [9, 5, 4, 8]인 경우에는 

NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.

입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 

둘째 줄에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.

출력

총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.

### 문제 분석하기

시간제한이 1초이고 1억번의 연산안에 해결해야한다.

주어진 N이 최대 100만까지가 가능하므로

N^2과 같은 시간복잡도로는 문제를 해결 할 수 없다.

따라서 일반적인 배열의 인덱스로 탐색하는 방식으로는

특정 인덱스번호에 해당하는 값에 대한 오큰수를 찾는 행위에서부터

시간복잡도가 N^2이 되버린다.

따라서 다른 자료구조나 알고리즘 기법을 사용해야 함을 고민해야한다.

여기서 stack을 이용하면 어떨까 라는 생각이 나올 수 있고

또한 stack을 이용하며 풀 때 어떤 값을 stack에 저장해야 할까? 를 고민해야 한다.

처음에 오큰수를 저장할까 싶었지만, 

오큰수를 저장하게 되면 결국 비교하는건 배열 비교랑 다를게 없기 때문에 안되고

공통 오큰수를 가지는 숫자들의 특징은 결국 자기 자신들의 오른쪽에서 가장 인접한 큰 수가 오큰수가 된다.

따라서 오큰수가 나올때 까지 주어진 수열을 스택에 넣다가

오큰수로 선정할 숫자가 결정되면 스택을 pop하면서 오큰수를 저장해야하는데

여기서 중요한 점은 스택에 수열의 인덱스 번호를 저장해야 오큰수를 저장할 배열에도 아무문제가 생기지 않는다는 점이다.

또한 오큰수를 찾지 못한 수열 인덱스번호에 대하여

스택에 남아있으므로 스택에 모두 pop 해주며 -1을 저장해준다.

결국 핵심은 어떤 자료구조로 해결 할 것인지? 와 어떤 데이터를 스택에 저장 할 것인지?를 해결하면 문제는 쉽게 풀린다.

### 손으로 풀어보기

N = 4

수열 = [3,5,2,7] 로 주어지면

반복문에 의해 

처음엔 스택이 비어있으므로

처음값 인덱스번호를 저장하고 다음 반복문으로 이어진다.

다음 반복문에서

스택에 값이 있고 그 값보다 5가 크므로

3에 해당하는 오큰수가 5로 정해졌다

오큰수를 저장하는 배열에 

스택에서 pop한 값(즉, 3에 해당하는 인덱스번호)을 인덱스번호로 가지는 공간에 저장한다.

그리고 5를 스택에 저장한다.

다음 반복문에서

스택에 값이 있고 2는 5보다 작으므로

스택에 2를 저장시킨다

다음 반복문에서 

스택에 값이 있고 7은 2보다 크므로

2에 해당하는 오큰수가 7로 정해졌다.

오큰수를 저장하는 배열에 

스택에서 pop한 값을 인덱스번호로 가지는 공간에 저장한다.

여기서 스택에 남은 값 모두를 저장하는 반복을 수행한다.

7을 저장한다.

스택에 남아있는 값이 있으므로

해당 값을 인덱스번호로 가지는 공간에 -1을 저장한다.

따라서 출력값 5 7 7 -1 이 된다.





