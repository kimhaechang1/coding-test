## 최장 증가 부분 수열(LIS)

최장 증가 부분 수열(LIS : Longest Increasing Subsequence)

주어진 수열에서 오름차순으로 정렬된 가장 긴 부분 수열을 찾는다.

여기서 부분 수열은 **연속적이거나, 유일할 필요는 없다**.

아래의 수열이 존재한다고 가정하면

```
1 5 2 3 1 7
```

여러 증가 부분 수열 중 

첫 번째 인덱스 원소를 기준으로 증가 수열을 하나 찾으면 

아래와 같은 수열이 된다.
```
1 5 7
```

이러한 증가 부분 수열중에서 최장 증가 부분 수열을 찾으면
```
1 2 3 7 
```
로서 길이 4로 최장 증가 부분 수열이 된다.

아래의 문제는 주어진 수열 ```[4 2 3 1 5 6]``` 에서

최장 증가 부분 수열의 길이를 구하는 문제를 풀어본다.

### O(N^2)의 시간복잡도인 동적계획법을 활용한 풀이

동적계획법은 특정 범위까지의 최적해(상위 문제)를 구하기 위하여 

다른 범위까지의 최적해(하위 문제)를 이용하여 효율적으로 해를 구하는 알고리즘 설계 기법이다.

즉, 이전에 구한 값을 기반으로 규칙성을 파악하여 다음 값을 구하는 것이라 생각하면 된다.

우선 LIS 를 구할 DP 테이블을 정의한다.

전체 중에서 가장 긴 증가 부분 수열의 길이를 구하려면 

```각 인덱스별 LIS값을 구하는것을 부분문제```로 생각해 볼 수 있다.

따라서 LIS를 구할 수열의 길이와 동일한 1차원 배열을 생성하고 첫 번째 인덱스부터 접근해본다.
```
Arr
[4, 2, 3, 1, 5, 6]

DP
[]
```
첫 번째 인덱스를 생각해보면 본인 자신이 우선 증가 부분 수열의 원소가 될 수 있으므로 1개를 누적한다.
```
Arr
[4, 2, 3, 1, 5, 6]

DP
[1]
```
두 번째 인덱스도 우선 본인 자신이 증가부분 수열의 원소가 될 수 있다.
```
Arr
[4, 2, 3, 1, 5, 6]

DP
[1, 1]
```
여기서 우리는 모든 인덱스의 LIS 값에 대하여 

본인자신이 원소가 되어야 하므로 1로 초기화 할 수 있다는점을 알 수 있다.
```
Arr
[4, 2, 3, 1, 5, 6]

DP
[1, 1, 1, 1, 1, 1]
```
다시 두 번째 인덱스를 보았을 때,

이전 인덱스의 원소값 보다 작으므로 4을 기준으로 증가 부분 수열에 포함시킬 수 없다.
```
Arr
[4, 2, 3, 1, 5, 6]

DP
[1, 1, 1, 1, 1, 1]
```
세번째 인덱스를 보았을 때,

이전 인덱스의 원소값들 중 4보단 작지만 2보단 크므로 2를 포함한 증가 부분 수열에 포함시킬 수 있다.

따라서 기준 인덱스 번호의 원소값을 2로 저장한다.
```
Arr
[4, 2, 3, 1, 5, 6]

DP
[1, 1, 2, 1, 1, 1]
```
네번째 인덱스를 보았을 때,

이전 인덱스의 원소값들 중 기준 원소보다 작은건 존재하지 않으므로 증가 부분 수열이 포함시킬 수 없다.
```
Arr
[4, 2, 3, 1, 5, 6]

DP
[1, 1, 2, 1, 1, 1]
```
다섯번째 인덱스를 보았을 때,

이전 인덱스의 원소값들 중 4, 2, 3, 1 모두 작으므로 이중 최장 증가 부분 수열이 될 수있는 값을 찾는다.

찾는방법은 지금까지의 인덱스별 증가부분수열은 

각 인덱스까지의 부분수열들 중에서 가장 길게 만들어 졌을 때의 길이를 갱신하고 있으므로

세번째 인덱스까지의 최장 증가 부분 수열의 길이에서 5를 포함시킨 길이가 새로운 최대값이 된다.

여기서 우리는 dp테이블 기준으로 

i번째 인덱스까지의 각 인덱스별 LIS값들중 최대값에 대하여 그 값의 +1한 값을 

dp 테이블에서 i번째 인덱스의 원소로 넣으며 갱신하면 된다는 규칙성을 찾을 수 있다.

```
Arr
[4, 2, 3, 1, 5, 6]

DP
[1, 1, 2, 1, dp[2]+1 > dp[4] = 3, 1]
```
마지막 6번째 인덱스를 보았을 때,

이전 인덱스의 원소값들 중 다섯번째 인덱스의 원소값이 가장 크고 그기서 6을 추가한것이 

기준 인덱스의 LIS가 되므로 ```dp[5]  = dp[4] + 1 ```이 된다.

```
Arr
[4, 2, 3, 1, 5, 6]

DP
[1, 1, 2, 1, 3, dp[4]+1 > dp[5] = 4]
```
위의 상황에서 점화식을 도출하면

DP 테이블기준 인덱스별로 1로 초기화해야하고

1번째 원소부터 i번째 원소 전까지 검사하여 

DP테이블 원소값+1 중에서 DP[i]보다 큰 값을 DP[i]에 저장한다.

### JAVA 코드

```java
class Main{
    public static void main(String []args){
        int [] arr = {4,2,3,1,5,6};
        int [] dp = new int[arr.length];
        int max = 1;
        for(int i= 0;i<arr.length;i++){
            dp[i] = 1; // 인덱스별 1로 초기화
            for(int k = 0;k<i;k++){ // 기준 인덱스전까지의 원소값 탐색
                if(dp[k] < dp[i]){ // 증가 부분 수열에 포함시킬수 있는 원소를 찾을경우
                    dp[i] = Math.max(dp[k]+1, dp[i]);
                    // 각 인덱스별 LIS값들에서 자신을 포함한 값을 새로운 LIS로 갱신
                }
            }
            Math.max(max, dp[i]); 
            // 기준 인덱스의 LIS 길이를 구했으므로 최대값을 갱신
        }
        System.out.println(max);
    }
}
```

### O(NlogN)의 시간복잡도인 동적계획법을 활용한 풀이

앞선 O(N^2) 의 시간복잡도 풀이에서 

기준 인덱스 전까지 기준 인덱스의 원소값보다 작은 값을 탐색하는 과정을 줄일 수 있을까? 라는 의문에서 시작한다.

똑같이 DP로 풀기 때문에 DP 테이블 정의를 한다.

현재까지 조사한 앞 원소들에 대하여, 부분 수열을 만들 수 있는 최적의 수의 조합을 저장하자.

예를 들어 1~ 기준원소 전 인덱스까지의 원소에서 i 번째 원소가 부분 수열에 포함 될 수 있는지 

쉽게 파악하기 위한 배열을 만든다

결국 이러한 배열을 끝 인덱스까지 탐색하여 완성시킨다면 

해당 배열의 길이가 곧 LIS가 된다.

이전의 O(n^2)같은 경우는 일반적인 dp문제와 달리 dp 배열에서 최대값을 찾아줘야 하지만

이 방법의 경우 dp 배열의 길이가 LIS가 된다.

우선 첫 번째 원소의 값을 dp에 곧바로 채워준다.

```
Arr
[4, 2, 3, 1, 5, 6]

DP
[4]
```
두 번째 원소의 경우에는, dp 테이블에 있는 원소보다 작으므로 

dp테이블의 첫 번째 인덱스 값을 기준 원소값으로 갱신 해 주어야한다.

왜냐하면 dp테이블은 현재 최적의 LIS를 구성 해야 하기 때문이다.

만약에 갱신해주지 않고 dp테이블에 해당원소를 추가 해 버린다면 

다음 원소들이 증가 부분 수열에 포함 될 수 있는지 재대로 파악 할 수 없게 되고

결국 최장 증가 부분 수열을 이룰 수 없게 된다.

따라서 dp 테이블의 ```원소보다 작거나 같으면 현재 가리키고 있는 dp인덱스의 원소를 기준 원소로 갱신 한다```.

```
Arr
[4, 2, 3, 1, 5, 6]

DP
[2]
```
다음 세번째 원소값을 보면 3으로 dp 테이블의 원소들 보다 크므로 증가 부분 수열에 포함시킬 수 있다.

언제까지나 dp테이블은 다음 원소가 증가 부분 수열의 최적의 원소인지 파악할 수 있어야 한다.

```
Arr
[4, 2, 3, 1, 5, 6]

DP
[2, 3]
```
다음 네번째 원소값을 보면 1으로 dp테이블의 원소들 중에서 가장 작은 원소보다 작으므로

가장 작은 원소와 기준 원소를 교체 해 준다.
```
Arr
[4, 2, 3, 1, 5, 6]

DP
[1, 3]
```
다음 다섯번째 원소값을 보면 5로 dp테이블의 원소들 중에서 가장 크므로

증가 부분 수열에 포함시킨다.
```
Arr
[4, 2, 3, 1, 5, 6]

DP
[1, 3, 5]
```
다음 마지막 원소값을 보면 6으로 dp테이블의 원소들 중에서 가장 크므로

증가 부분 수열에 포함시킨다.
```
Arr
[4, 2, 3, 1, 5, 6]

DP
[1, 3, 5, 6]
```

이제 dp 배열의 길이를 구하면 LIS 값 4로 결정된다.

이제 앞선 과정들에게서 규칙성을 찾아서 점화식을 도출한다.

원소를 추가할 때 마다 dp 테이블에서 기준 원소보다 큰 값을 찾는다.

그런 값이 존재한다면 그런 값들 중 가장 작은값과 기준 원소값을 교체 해 주고

그런 값이 존재하지 않는다면, dp 테이블에 해당 기준 원소값을 추가 해 준다.

이 때 중요한 점은 dp 테이블에서 탐색 할 원소들은 ```오름차순으로 정렬```되어 있으므로

```이분탐색```을 통해 빠르게 접근이 가능하다.

```java
class Main{
    static int [] arr;
    static int [] dp;
    public static void main(String []args){
        arr = new int[]{4,2,3,1,5,6};
        dp = new int[arr.length];
        int LIS = 0;
        for(int i= 0;i<arr.length;i++){
            int idx= LowerBoundBinarySearch(arr[i], 0, LIS);
            dp[idx] = arr[i];
            if(idx == LIS){
                LIS++;
            }
        }
        System.out.println(LIS);
    }
    static int LowerBoundBinarySearch(int find, int start, int end){
        while(start< end){
            int mid = (end+start)/2;
            if(dp[mid]<find){
                start = mid+1;
            }else{
                end = mid;
            }
        }
        return end;    
    }
}   
```

출처 : 

[[Java]동적 계획법(Dynamic Programming)](https://sskl660.tistory.com/87)

[[Java]최장 증가 부분 수열(LIS, Longest Increasing Subsequence)](https://sskl660.tistory.com/89)

