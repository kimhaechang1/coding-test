## 기수정렬

기수정렬은 값을 비교하지 않는 특이한 정렬

기수 정렬은 값을 놓고 비교할 자리릇수를 정한 다음 해당 자릿수만 비교한다.

기수정렬의 시간복잡도는 O(kn)으로

여기서 k는 데이터의 자리수를 말한다.

### 기수정렬의 핵심이론

계수정렬의 이론을 잠깐 배껴와서 해결한다.

계수정렬의 핵심이론은

각각의 데이터가 몇회 나왔는지 카운팅하고

그 카운팅 배열의 누적합 배열을 구한다.

마지막으로 찾고자 하는 값의 정렬된 데이터 속 인덱스번호를 구하려면

누적합배열[찾고자 하는 값]- 1이 정렬된 배열에서의 인덱스가 된다.

이를 기수정렬에서 사용하면

처음에 1의 자리수에 해당하는 각각의 카운팅 배열을 구하고

누적합을 구한 다음

임시배열[누적합배열[원본숫자의 1의 자리수]-1] = 원본배열의 값

을 해 주고

임시배열의 값을 그대로 원본배열로 복사해서 넣은 다음

자리수를 늘려서 다시 반복시켜서 정렬한다.

### 기수정렬의 수행방식

1. 문제에서 주어진 최대 숫자의 크기를 찾는다.

2. 최대숫자의 크기에 따라 반복 할 횟수를 정한다.

3. 최대크기만큼 반복하면서 자리수 카운팅 배열을 구한다.

4. 자리수 카운팅 배열을 누적합 배열로 바꾼다.

5. 원하는 값에 대응하는 누적합 값 -1을 인덱스로 갖는 정렬된 배열에 원하는값을 넣는다.

6. 자리수를 늘려주며 최대 반복할 횟수까지 1~5번을 반복한다.

### 기수정렬의 기본형

숫자의 최대크기가 10000으로 주어졌다고 가정한다.
```java
int radixSort(int []arr, int max){
    int []temp = new int[arr.length]; // 임시배열
    int cnt = 0 // 반복 할 횟수 카운트
    int j = 1 // 구해야 할 자리수 -> 일의 자리수부터 

    while(cnt != max){
        // 자리수 카운팅 배열을 구해야한다.
        int []count = new int[10];
        for(int i= 0;i<count.length;i++){
            count[arr[i]/j%10]++;
        }
        // 카운팅 배열에 대한 누적합을 구한다.
        for(int i = 1;i<count.length;i++){
            count[i] += count[i-1];
        }

        // 원하는 값에 대응하는 누적합 값 -1 이 원하는 값에 대한 정렬된 인덱스번호가 된다.
        // 즉, temp[count[arr[i]/j%10]-1] = arr[i]

        for(int i = arr.length-1;i>-1;i++){
            temp[count[arr[i]/j%10]-1] = arr[i];
            count[arr[i]/j%10]--;
        }
        // 정렬된 임시배열의 원소를 그대로 원본배열에 넣는다.
        for(int i = 0;i<arr.length;i++){
            arr[i] = temp[i];
        }
        
        // 다음 자리수를 구하고 위의 행동을 반복한다.
        j = j * 10;
        cnt++;
    }
}
```


