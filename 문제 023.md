## 연결 요소의 개수 구하기

문제

방향 없는 그래프가 주어졌을 때, 

연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오.

입력

첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. 

(1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2) 

둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. 

(1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다.

출력

첫째 줄에 연결 요소의 개수를 출력한다.

### 문제 분석하기

시간제한이 3초이므로 3억번의 연산내외로 해결해야 한다.

문제에서 방향없는 그래프로 말이 나왔으므로 그래프이론으로 문제를 해결한다.

연결 요소의 개수를 구한다는 말은

깊이우선탐색을 서브테스크로 두었을 때

시작점에서 부터 가동되는 서브테스크들을 전부 돌았을 경우 하나의 연결요소를 가진다고 볼 수 있다

다른 시작점으로 시작하기 위해서는

이전 서브테스크에서 이미 방문하였던 정점들은 무시하고 방문한적 없는 정점에 대하여 새로운 시작점으로 두고 

서브테스크를 시작한다.


### 손으로 풀어보기

1을 시작점으로 서브테스크를 시작하면

시작점 1 ->

1 -> 2방문 -> 2의 인접 리스트로 진입

2 -> 1방문 -> 방문한적 있으므로 return

  -> 5방문 -> 5의 인접 리스트로 진입

5 -> 1방문 -> 방문한적 있으므로 return

  -> 2방문 -> 방문한적 있으므로 return

1 -> 5방문 -> 방문한적 있으므로 return

시작점 1에 대한 서브테스크 완전종료

count + 1;

시작점 2는 방문한적 있으므로 continue

시작점 3은 방문한적 없으므로 서브테스크 실행

### 슈도코드 작성

```java
static ArrayList<Integer>[] g; : 그래프

static boolean []v; : 방문여부 배열

dfs(n){
    visited[n] = true;
    
    for(int node : g[n]){
        if(!visited[node]){
            dfs(node);
        }
    }
}

main(){
    int n : 정점의 개수
    int m : 간선의 개수
    int count = 0 : 연결요소의 개수
    g = ArrayList[n+1];
    for(int i : 1~n+1){
        g[i] = new ArrayList<>(); : 그래프 초기화
    }
    for(int i : 0~m){
        그래프 간선정보 등록
        g[s].add(e)
        g[e].add(s) 
    }
    for(int i : 1~n+1){
        if(!visited[i]){
            count++;
            dfs(i);
        }
    }
}


```




